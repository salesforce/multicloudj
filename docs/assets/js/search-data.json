{"0": {
    "doc": "Api Documentation",
    "title": "Java API documentation of the SDK",
    "content": " ",
    "url": "/multicloudj/api-java-doc.html#java-api-documentation-of-the-sdk",
    
    "relUrl": "/api-java-doc.html#java-api-documentation-of-the-sdk"
  },"1": {
    "doc": "Api Documentation",
    "title": "Api Documentation",
    "content": "Java doc link for MultiCloudJ . ",
    "url": "/multicloudj/api-java-doc.html",
    
    "relUrl": "/api-java-doc.html"
  },"2": {
    "doc": "How to Blob store",
    "title": "BucketClient",
    "content": "The BucketClient class in the multicloudj library provides a comprehensive, cloud-agnostic interface to interact with individual buckets in object storage services like AWS S3, Azure Blob Storage, and Google Cloud Storage. This client enables uploading, downloading, deleting, listing, copying, and managing blob metadata and multipart uploads across multiple cloud providers. ",
    "url": "/multicloudj/guides/blobstore-guide.html#bucketclient",
    
    "relUrl": "/guides/blobstore-guide.html#bucketclient"
  },"3": {
    "doc": "How to Blob store",
    "title": "Feature Support Across Providers",
    "content": "Core API Features . | Feature Name | GCP | AWS | ALI | Comments | . | Basic Upload | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Upload from InputStream, byte[], File, Path | . | Basic Download | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Download to OutputStream, byte[], File, Path | . | Delete Objects | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Single and batch delete operations | . | Copy Objects | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Server-side copy within and across buckets | . | Get Metadata | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Retrieve object metadata and properties | . | List Objects | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Paginated listing with filters | . | Object Tagging | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Get and set object tags | . | Presigned URLs | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Generate temporary access URLs | . | Versioning Support | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Object version-specific operations | . Multipart Upload Features . | Feature Name | GCP | AWS | ALI | Comments | . | Initiate Multipart | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Start multipart upload session | . | Upload Part | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Upload individual parts | . | Complete Multipart | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Finalize multipart upload | . | List Parts | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | List uploaded parts | . | Abort Multipart | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Cancel multipart upload | . Advanced Features . | Feature Name | GCP | AWS | ALI | Comments | . | Async Operations | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | üìÖ In Roadmap | CompletableFuture-based async API available only for AWS | . | Bucket Operations | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | List buckets via BlobClient | . Configuration Options . | Configuration | GCP | AWS | ALI | Comments | . | Regional Support | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Region-specific bucket operations | . | Endpoint Override | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Custom endpoint configuration | . | Proxy Support | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | HTTP proxy configuration | . | Credentials Override | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Custom credential providers via STS | . Provider-Specific Notes . ",
    "url": "/multicloudj/guides/blobstore-guide.html#feature-support-across-providers",
    
    "relUrl": "/guides/blobstore-guide.html#feature-support-across-providers"
  },"4": {
    "doc": "How to Blob store",
    "title": "Creating a Client",
    "content": "BucketClient bucketClient = BucketClient.builder(\"aws\") .withRegion(\"us-west-2\") .withBucket(\"my-bucket\") .build(); . You can also configure advanced options: . URI endpoint = URI.create(\"https://custom-endpoint.com\"); URI proxy = URI.create(\"https://proxy.example.com\"); bucketClient = BucketClient.builder(\"aws\") .withRegion(\"us-west-2\") .withBucket(\"my-bucket\") .withEndpoint(endpoint) .withProxyEndpoint(proxy) .build(); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#creating-a-client",
    
    "relUrl": "/guides/blobstore-guide.html#creating-a-client"
  },"5": {
    "doc": "How to Blob store",
    "title": "Uploading Files",
    "content": "Supports various sources: . UploadRequest request = new UploadRequest(\"object-key\"); bucketClient.upload(request, inputStream); bucketClient.upload(request, new File(\"file.txt\")); bucketClient.upload(request, path); bucketClient.upload(request, byteArray); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#uploading-files",
    
    "relUrl": "/guides/blobstore-guide.html#uploading-files"
  },"6": {
    "doc": "How to Blob store",
    "title": "Downloading Files",
    "content": "DownloadRequest request = new DownloadRequest(\"object-key\"); bucketClient.download(request, outputStream); bucketClient.download(request, new File(\"dest.txt\")); bucketClient.download(request, path); bucketClient.download(request, byteArray); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#downloading-files",
    
    "relUrl": "/guides/blobstore-guide.html#downloading-files"
  },"7": {
    "doc": "How to Blob store",
    "title": "Listing Blobs",
    "content": "ListBlobsRequest request = new ListBlobsRequest(); Iterator&lt;BlobInfo&gt; blobs = bucketClient.list(request); while (blobs.hasNext()) { System.out.println(blobs.next().getName()); } . ",
    "url": "/multicloudj/guides/blobstore-guide.html#listing-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#listing-blobs"
  },"8": {
    "doc": "How to Blob store",
    "title": "Deleting Blobs",
    "content": "bucketClient.delete(\"object-key\", null); // optional versionId Collection&lt;BlobIdentifier&gt; toDelete = List.of( new BlobIdentifier(\"object1\"), new BlobIdentifier(\"object2\") ); bucketClient.delete(toDelete); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#deleting-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#deleting-blobs"
  },"9": {
    "doc": "How to Blob store",
    "title": "Copying Blobs",
    "content": "CopyRequest copyRequest = new CopyRequest(); // populate source and destination CopyResponse response = bucketClient.copy(copyRequest); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#copying-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#copying-blobs"
  },"10": {
    "doc": "How to Blob store",
    "title": "Metadata and Tags",
    "content": "BlobMetadata metadata = bucketClient.getMetadata(\"object-key\", null); Map&lt;String, String&gt; tags = bucketClient.getTags(\"object-key\"); bucketClient.setTags(\"object-key\", Map.of(\"env\", \"prod\")); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#metadata-and-tags",
    
    "relUrl": "/guides/blobstore-guide.html#metadata-and-tags"
  },"11": {
    "doc": "How to Blob store",
    "title": "Presigned URLs",
    "content": "PresignedUrlRequest presignedRequest = new PresignedUrlRequest(); URL url = bucketClient.generatePresignedUrl(presignedRequest); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#presigned-urls",
    
    "relUrl": "/guides/blobstore-guide.html#presigned-urls"
  },"12": {
    "doc": "How to Blob store",
    "title": "Multipart Uploads",
    "content": "MultipartUploadRequest initRequest = new MultipartUploadRequest(); MultipartUpload upload = bucketClient.initiateMultipartUpload(initRequest); UploadPartResponse part = bucketClient.uploadMultipartPart(upload, partData); List&lt;UploadPartResponse&gt; parts = List.of(part1, part2); bucketClient.completeMultipartUpload(upload, parts); List&lt;UploadPartResponse&gt; uploadedParts = bucketClient.listMultipartUpload(upload); bucketClient.abortMultipartUpload(upload); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#multipart-uploads",
    
    "relUrl": "/guides/blobstore-guide.html#multipart-uploads"
  },"13": {
    "doc": "How to Blob store",
    "title": "Error Handling",
    "content": "All operations may throw SubstrateSdkException. These can be caught and handled generically: . try { bucketClient.upload(request, new File(\"file.txt\")); } catch (SubstrateSdkException e) { // Handle access denied, IO failure, etc. e.printStackTrace(); } . Use BucketClient when you need full CRUD support and advanced control over blobs inside a single bucket, across any supported cloud provider. ",
    "url": "/multicloudj/guides/blobstore-guide.html#error-handling",
    
    "relUrl": "/guides/blobstore-guide.html#error-handling"
  },"14": {
    "doc": "How to Blob store",
    "title": "How to Blob store",
    "content": " ",
    "url": "/multicloudj/guides/blobstore-guide.html",
    
    "relUrl": "/guides/blobstore-guide.html"
  },"15": {
    "doc": "How to Docstore",
    "title": "Docstore",
    "content": "The DocStoreClient class in the multicloudj library provides a portable document store like abstraction over NoSQSL database providers like Amazon DynamoDB, Alibaba Tablestore, and Google Firestore. It supports core document operations like create, read, update, delete (CRUD), batching, and querying with the support of indexing. Internally, each provider is implemented via a driver extending AbstractDocStore. ",
    "url": "/multicloudj/guides/docstore-guide.html#docstore",
    
    "relUrl": "/guides/docstore-guide.html#docstore"
  },"16": {
    "doc": "How to Docstore",
    "title": "Feature Support Across Providers",
    "content": "Core API Features . | Feature Name | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Create Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Insert new documents | . | Get Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Get the document by key | . | Put Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Insert or replace document | . | Replace Document | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Replace existing document | . | Delete Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Remove document by key | . | Update Document | ‚è±Ô∏è End of June‚Äô25 | ‚è±Ô∏è Coming Soon | ‚è±Ô∏è Coming Soon | Update operations not yet implemented in any provider | . Batch Operations . | Feature Name | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Batch Get | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Retrieve multiple documents in one call | . | Batch Write | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Write multiple documents atomically | . | Atommic Writes | ‚è±Ô∏è End of June‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Atomic write operations across multiple documents | . Query Features . | Feature Name | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Basic Queries | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Filter and projection queries | . | Compound Filters | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Multiple filter conditions | . | Order By | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Sort query results | . | Order By in Full Scan | ‚ùå Not Supported | ‚ùå Not Supported | ‚ùå Not Supported | ** It‚Äôs too expensive ** | . | Limit/Offset | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Pagination support | . | Index-based Queries | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Query using secondary indexes | . | Query Planning | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Explain query execution plans | . Advanced Features . | Feature Name | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Revision/Versioning | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Optimistic concurrency control | . | Single Key Collections | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Collections with only partition key | . | Two Key Collections | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Collections with partition + sort key(uses indexes in firestore) | . Configuration Options . | Configuration | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Regional Support | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Region-specific operations | . | Custom Endpoints | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Override default service endpoints | . | Credentials Override | ‚úÖ Supported | ‚úÖ Supported | üìÖ In Roadmap | Custom credential providers via STS | . | Collection Options | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Table/collection configuration | . ",
    "url": "/multicloudj/guides/docstore-guide.html#feature-support-across-providers",
    
    "relUrl": "/guides/docstore-guide.html#feature-support-across-providers"
  },"17": {
    "doc": "How to Docstore",
    "title": "Creating a Client",
    "content": "To begin using DocStoreClient, use the static builder: . CollectionOptions collectionOptions = new CollectionOptions.CollectionOptionsBuilder() .withTableName(\"chameleon-test\") .withPartitionKey(\"pName\") .withSortKey(\"s\") .withRevisionField(\"docRevision\") .build(); DocStoreClient client = DocStoreClient.builder(\"aws\") .withRegion(\"us-west-2\") .withCollectionOptions(collectionOptions) .build(); . ",
    "url": "/multicloudj/guides/docstore-guide.html#creating-a-client",
    
    "relUrl": "/guides/docstore-guide.html#creating-a-client"
  },"18": {
    "doc": "How to Docstore",
    "title": "Document Representation",
    "content": "The Document class accepts either a user-defined class or a generic map. Option 1: Using a POJO (Player) . @AllArgsConstructor @NoArgsConstructor @Data public class Player { private String pName; private int i; private float f; private boolean b; private String s; } Player player = new Player(\"Alice\", 42, 99.5f, true, \"metadata\"); Document doc = new Document(player); . Option 2: Using a HashMap . Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"pName\", \"Alice\"); map.put(\"i\", 42); map.put(\"f\", 99.5f); map.put(\"b\", true); map.put(\"s\", \"metadata\"); Document doc = new Document(map); . ",
    "url": "/multicloudj/guides/docstore-guide.html#document-representation",
    
    "relUrl": "/guides/docstore-guide.html#document-representation"
  },"19": {
    "doc": "How to Docstore",
    "title": "Actions",
    "content": "Once you have initialized a docstore client, you can call action methods on it to read, modify, and write documents. These are referred to as actions, and can be executed individually or as part of a batch using an action list. DocStore supports the following types of actions: . | Get retrieves a document. | Create creates a new document. | Replace replaces an existing document. | Put puts a document whether or not it already exists. | Update applies modifications to a document (not supported yet). | Delete deletes a document. | . Each of the following examples illustrates one of these actions. ",
    "url": "/multicloudj/guides/docstore-guide.html#actions",
    
    "relUrl": "/guides/docstore-guide.html#actions"
  },"20": {
    "doc": "How to Docstore",
    "title": "Basic Operations",
    "content": "Create . Create will throw an exception ResourceAlreadyExists if the document already exists. client.create(doc); . Get . To retrieve a document, you must provide a Document initialized with the corresponding object and pre-populate the fields that uniquely identify it (e.g., partition key and sort key): . Player player = new Player(); player.setPName(\"Alice\"); // Assuming pName is the partition key player.setS(\"metadata\"); // Assuming s is the sort key client.get(new Document(player)); . With optional fields you want to retrieve: . client.get(new Document(player), \"pName\", \"f\"); . Replace . Replaces the existing doc, will throw ResourceNotFound is the document doesn‚Äôt exist. client.replace(doc); . Put . Put is similar to create but will not throw in case the document doesn‚Äôt exist. client.put(doc); . Delete . To delete a document, the input must also have the required key fields populated: . Player player = new Player(); player.setPName(\"Alice\"); player.setS(\"metadata\"); client.delete(new Document(player)); . Update (Not Supported) . client.update(doc, Map.of(\"f\", 120.0f)); // Throws UnSupportedOperationException . ",
    "url": "/multicloudj/guides/docstore-guide.html#basic-operations",
    
    "relUrl": "/guides/docstore-guide.html#basic-operations"
  },"21": {
    "doc": "How to Docstore",
    "title": "Batch Operations",
    "content": "Batch Get . List&lt;Document&gt; docs = List.of( new Document().put(\"pName\", \"Alice\").put(\"s\", \"metadata\"), new Document().put(\"pName\", \"Bob\").put(\"s\", \"stats\") ); client.batchGet(docs); . Batch Put . List&lt;Document&gt; docs = List.of( new Document().put(\"pName\", \"Alice\").put(\"f\", 10.5f), new Document().put(\"pName\", \"Bob\").put(\"f\", 20.0f) ); client.batchPut(docs); . ",
    "url": "/multicloudj/guides/docstore-guide.html#batch-operations-1",
    
    "relUrl": "/guides/docstore-guide.html#batch-operations-1"
  },"22": {
    "doc": "How to Docstore",
    "title": "Queries",
    "content": "DocStore‚Äôs get action retrieves a single document by its primary key. However, when you need to retrieve or manipulate multiple documents that match a condition, you can use queries. Queries allow you to: . | Retrieve all documents that match specific conditions. | Delete or update documents in bulk based on criteria. | . The query interface is chainable and supports filtering and sorting (depending on driver support). DocStore can also optimize queries automatically. Based on your filter conditions, it attempts to determine whether a global secondary index (GSI) or a local secondary index (LSI) can be used to execute the query more efficiently. This helps reduce latency and improves performance. Queries support the following methods: . | Where: Describes a condition on a document. You can ask whether a field is equal to, greater than, or less than a value. The ‚Äúnot equals‚Äù comparison isn‚Äôt supported, because it isn‚Äôt portable across providers. | OrderBy: Specifies the order of the resulting documents, by field and direction. For portability, you can specify at most one OrderBy, and its field must also be mentioned in a Where clause. | Limit: Limits the number of documents in the result. | . Query query = client.query(); // Apply filtering, sorting, etc. (Depends on driver implementation.) . ",
    "url": "/multicloudj/guides/docstore-guide.html#queries",
    
    "relUrl": "/guides/docstore-guide.html#queries"
  },"23": {
    "doc": "How to Docstore",
    "title": "Advanced Usage",
    "content": "Action Lists . ActionList actions = client.getActions(); actions.put(doc1).get(doc2).delete(doc3); actions.run(); . You can also chain operations directly using the fluent API with enableAtomicWrites() for atomic execution: . client.getActions() .create(new Document(new Player(\"Alice\", 1, 3.99f, true, \"CA\"))) .create(new Document(new Player(\"Bob\", 2, 3.99f, true, \"PT\"))) .create(new Document(new Player(\"Carol\", 3, 3.99f, true, \"PA\"))) .enableAtomicWrites() .create(new Document(new Player(\"Dave\", 4, 3.99f, true, \"TX\"))) .create(new Document(new Player(\"Eve\", 5, 3.99f, true, \"OR\"))) .create(new Document(new Player(\"Frank\", 6, 3.99f, true, \"NJ\"))) .run(); . Atomic Writes: . If you want to write your documents atomically, just use the enableAtomicWrites as above and all the writes are this will be executed atomically. Close the Client . client.close(); . ",
    "url": "/multicloudj/guides/docstore-guide.html#advanced-usage",
    
    "relUrl": "/guides/docstore-guide.html#advanced-usage"
  },"24": {
    "doc": "How to Docstore",
    "title": "How to Docstore",
    "content": " ",
    "url": "/multicloudj/guides/docstore-guide.html",
    
    "relUrl": "/guides/docstore-guide.html"
  },"25": {
    "doc": "Exception Handling",
    "title": "Exception Handling in Substrate SDK",
    "content": " ",
    "url": "/multicloudj/design/errors.html#exception-handling-in-substrate-sdk",
    
    "relUrl": "/design/errors.html#exception-handling-in-substrate-sdk"
  },"26": {
    "doc": "Exception Handling",
    "title": "How Does Exception Handling Work for SDK Users?",
    "content": "Substrate SDK defines substrate-agnostic exceptions for end users, so they don‚Äôt have to deal with substrate-specific exceptions directly. The SDK wraps all exceptions from cloud providers in a standardized wrapper based on the exception type before propagating it to the end user. Some broadly categorized exceptions include: . | SubstrateSdkException ‚Äì&gt; Base class for all the exceptions | AccessDeniedException | ResourceNotFoundException | ResourceAlreadyExistsException | ResourceExhaustedException | InvalidArgumentException | FailedPreConditionException | DeadlineExceededException | ResourceConflictException | UnAuthorizedException | UnSupportedOperationException | UnknownException ‚Äì&gt; This is used when no predefined mapping exists. Ideally, as the SDK evolves, there should be no occurrences of this exception. | . ",
    "url": "/multicloudj/design/errors.html#how-does-exception-handling-work-for-sdk-users",
    
    "relUrl": "/design/errors.html#how-does-exception-handling-work-for-sdk-users"
  },"27": {
    "doc": "Exception Handling",
    "title": "How Does Exception Handling Work for Provider Implementations?",
    "content": "Handling Server-Side Exceptions . Server-side exceptions are relatively straightforward because provider implementations do not need to process them explicitly. These exceptions are considered RunTimeExceptions, which are thrown to the client layer and wrapped according to the predefined mapping. When Provider Implementations Need to Throw Exceptions . There are cases where provider implementations must throw SubstrateSdkException themselves. Some examples include: . | Input Validation Failures . | If a provider implementation validates input parameters and detects an issue, it can throw an InvalidArgumentException directly. | . | Converting Server-Side Exceptions to Different Semantics . | In some cases, a provider implementation may need to reinterpret server-side exceptions. | Example: In DocStore, the create API expects the item not to exist, while the put API does not have this constraint. If a key already exists, the provider must decide which exception to throw based on the API semantics. | . | . Exception Wrapping . | If the exception is already a subclass of SubstrateSdkException, it is not re-wrapped. | Otherwise, exceptions are wrapped according to predefined mappings to ensure a consistent experience for SDK users. | . ",
    "url": "/multicloudj/design/errors.html#how-does-exception-handling-work-for-provider-implementations",
    
    "relUrl": "/design/errors.html#how-does-exception-handling-work-for-provider-implementations"
  },"28": {
    "doc": "Exception Handling",
    "title": "Exception Handling",
    "content": " ",
    "url": "/multicloudj/design/errors.html",
    
    "relUrl": "/design/errors.html"
  },"29": {
    "doc": "Flexibility",
    "title": "Flexibility",
    "content": "Substrate SDK remains extensible and you can have your custom providers implementing the driver layer and include the provider jar in the classpath. All you need to do is load the provider with providerId, for example: . BucketClient.builder(\"&lt;BlobstoreCustomProvider&gt;\")... DocstoreClient.builder(\"DocstoreCustomProvider\")... You can also keep the providers outside of this SDK repo anywhere as long as they have access to driver layer. There might be few use-case where you want to tweak the implementation provided by Substrate SDK for your special requirements. You can can have your own implementation overriding the the implementation provided by Substrate SDK and provide that in the runtime. ",
    "url": "/multicloudj/design/flexibility.html",
    
    "relUrl": "/design/flexibility.html"
  },"30": {
    "doc": "MultiCloudJ Overview",
    "title": "MultiCloudJ",
    "content": "Multi-substrate Java SDK providing unified and substrate-neutral interfaces for cloud services such as Security Token Service (STS), Blob Storage, Key-Value Store, and more. ",
    "url": "/multicloudj/#multicloudj",
    
    "relUrl": "/#multicloudj"
  },"31": {
    "doc": "MultiCloudJ Overview",
    "title": "Maven Dependencies",
    "content": "&lt;dependency&gt; &lt;groupId&gt;com.salesforce.multicloudj&lt;/groupId&gt; &lt;artifactId&gt;{service}-client&lt;/artifactId&gt; &lt;version&gt;{version}&lt;/version&gt; &lt;/dependency&gt; . ",
    "url": "/multicloudj/#maven-dependencies",
    
    "relUrl": "/#maven-dependencies"
  },"32": {
    "doc": "MultiCloudJ Overview",
    "title": "Running Examples",
    "content": "MultiCloudJ includes various example programs demonstrating how to interact with supported services like STS, Blob Storage, and Doc Stores. Examples are located in the examples directory. ",
    "url": "/multicloudj/#running-examples",
    
    "relUrl": "/#running-examples"
  },"33": {
    "doc": "MultiCloudJ Overview",
    "title": "Service supported as of now",
    "content": "MultiCloudJ provides substrate-neutral interfaces supporting the following service: . | STS (Security Token Service) | BlobStore | Document Store | . ",
    "url": "/multicloudj/#service-supported-as-of-now",
    
    "relUrl": "/#service-supported-as-of-now"
  },"34": {
    "doc": "MultiCloudJ Overview",
    "title": "Integration with Cloud Providers",
    "content": "MultiCloudJ provides substrate-neutral interfaces supporting multiple cloud providers, including: . | AWS | Alibaba | GCP | . ",
    "url": "/multicloudj/#integration-with-cloud-providers",
    
    "relUrl": "/#integration-with-cloud-providers"
  },"35": {
    "doc": "MultiCloudJ Overview",
    "title": "Where to Go from Here",
    "content": "Documentation and Guides: . | How to guides: How to use guides for developers ready to use the SDK. | Design decisions: Some critical design decisions behind the SDK. | . API Documentation: . | Java API Documentation (Javadoc) | . Community and Support: . | GitHub Issues | Discussion Forum | Contribution Guidelines | . Additional Resources: . | MultiCloudJ Homepage | Release Notes | Examples | . ",
    "url": "/multicloudj/#where-to-go-from-here",
    
    "relUrl": "/#where-to-go-from-here"
  },"36": {
    "doc": "MultiCloudJ Overview",
    "title": "MultiCloudJ Overview",
    "content": " ",
    "url": "/multicloudj/",
    
    "relUrl": "/"
  },"37": {
    "doc": "Design",
    "title": "Design Guides",
    "content": "Welcome to the MultiCloudJ Design Guides. This section provides concise, task-focused guides to help you understand the key design decisions behind the SDK. | Layers of the SDK - Understanding the layered architecture | Error Handling - How errors are handled across the SDK | Flexibility - How to extend and customize the SDK | . ",
    "url": "/multicloudj/design/#design-guides",
    
    "relUrl": "/design/#design-guides"
  },"38": {
    "doc": "Design",
    "title": "Core Design Principles",
    "content": "MultiCloudJ is built on several key principles: . | Substrate Agnosticism: The SDK provides a unified interface that works consistently across different cloud providers. | Extensibility: New cloud providers can be added without modifying existing code. | Simplicity: The API is designed to be intuitive and easy to use. | Performance: The SDK is optimized for efficient cloud service interactions. | Reliability: Robust error handling and retry mechanisms ensure reliable operation. | . ",
    "url": "/multicloudj/design/#core-design-principles",
    
    "relUrl": "/design/#core-design-principles"
  },"39": {
    "doc": "Design",
    "title": "Contributing to Design",
    "content": "We welcome contributions to improve MultiCloudJ‚Äôs design. When contributing: . | Follow the established architectural patterns | Document your design decisions | Consider backward compatibility | Test your changes thoroughly | Update relevant documentation | . ",
    "url": "/multicloudj/design/#contributing-to-design",
    
    "relUrl": "/design/#contributing-to-design"
  },"40": {
    "doc": "Design",
    "title": "Design Decisions",
    "content": "Key design decisions in MultiCloudJ include: . | Layered Architecture: Separating concerns between portable, driver, and provider layers | Builder Pattern: Using builders for flexible client configuration | Provider Loading: Dynamic loading of cloud provider implementations | Error Handling: Comprehensive error handling and recovery mechanisms | Extensibility: Support for custom providers and implementations | . ",
    "url": "/multicloudj/design/#design-decisions",
    
    "relUrl": "/design/#design-decisions"
  },"41": {
    "doc": "Design",
    "title": "Best Practices",
    "content": "When working with MultiCloudJ‚Äôs design: . | Keep it Simple: Prefer simple solutions over complex ones | Be Consistent: Follow established patterns and conventions | Think Ahead: Consider future extensibility and maintenance | Document Everything: Clear documentation is essential | Test Thoroughly: Ensure your changes work across all supported providers | . ",
    "url": "/multicloudj/design/#best-practices",
    
    "relUrl": "/design/#best-practices"
  },"42": {
    "doc": "Design",
    "title": "Related Resources",
    "content": ". | API Documentation | How-to Guides | Examples | Contribution Guidelines | . ",
    "url": "/multicloudj/design/#related-resources",
    
    "relUrl": "/design/#related-resources"
  },"43": {
    "doc": "Design",
    "title": "Design",
    "content": " ",
    "url": "/multicloudj/design/",
    
    "relUrl": "/design/"
  },"44": {
    "doc": "Usage Guides",
    "title": "How-To Guides",
    "content": "Welcome to the MultiCloudJ How-To Guides. This section provides concise, task-focused guides designed to help you accomplish common goals using MultiCloudJ‚Äôs cloud-agnostic interfaces. Each guide is grouped by API and includes practical examples and usage patterns. ",
    "url": "/multicloudj/guides/#how-to-guides",
    
    "relUrl": "/guides/#how-to-guides"
  },"45": {
    "doc": "Usage Guides",
    "title": "üõ°Ô∏è STS",
    "content": "Learn how to get access credentials using roles/service accounts etc. | STS | . ",
    "url": "/multicloudj/guides/#%EF%B8%8F-sts",
    
    "relUrl": "/guides/#Ô∏è-sts"
  },"46": {
    "doc": "Usage Guides",
    "title": "‚òÅÔ∏è Blob",
    "content": "Learn how to manage object storage (uploading, downloading, listing blobs) in a cloud-neutral way. | Blob Store | . ",
    "url": "/multicloudj/guides/#%EF%B8%8F-blob",
    
    "relUrl": "/guides/#Ô∏è-blob"
  },"47": {
    "doc": "Usage Guides",
    "title": "üìÑ Docstore",
    "content": "Work with document-oriented databases using a consistent interface. | Docstore | . ",
    "url": "/multicloudj/guides/#-docstore",
    
    "relUrl": "/guides/#-docstore"
  },"48": {
    "doc": "Usage Guides",
    "title": "üì¨ Pub/Sub",
    "content": "Use publish/subscribe systems to send and receive messages. | Pubsub | . Explore these guides to master the MultiCloudJ SDK and build robust multi-cloud Java applications with ease. ",
    "url": "/multicloudj/guides/#-pubsub",
    
    "relUrl": "/guides/#-pubsub"
  },"49": {
    "doc": "Usage Guides",
    "title": "Usage Guides",
    "content": " ",
    "url": "/multicloudj/guides/",
    
    "relUrl": "/guides/"
  },"50": {
    "doc": "Layers",
    "title": "Layers",
    "content": " ",
    "url": "/multicloudj/design/layers.html",
    
    "relUrl": "/design/layers.html"
  },"51": {
    "doc": "Layers",
    "title": "Introduction",
    "content": "The Substrate SDK uses a layered architecture to provide a clean separation between the public API, internal abstractions, and provider-specific implementations. This architecture enables: . | A consistent, substrate-agnostic experience for end users | Easy addition of new cloud providers | Clear separation of concerns | Maintainable and testable code | . ",
    "url": "/multicloudj/design/layers.html#introduction",
    
    "relUrl": "/design/layers.html#introduction"
  },"52": {
    "doc": "Layers",
    "title": "Components",
    "content": ". The architecture consists of three main layers: . | Portable Layer (Top) - The public-facing API that users interact with | Driver Layer (Middle) - The abstraction layer that defines common interfaces | Provider Layer (Bottom) - The implementation layer for specific cloud providers | . ",
    "url": "/multicloudj/design/layers.html#components",
    
    "relUrl": "/design/layers.html#components"
  },"53": {
    "doc": "Layers",
    "title": "Portable Layer",
    "content": "The portable layer is the most important and front-facing layer for end users. End users should mostly interact with the portable Layer to make cloud service calls. The portable Layer should expose all necessary functions/APIs for the end user. For example, for a blobstore service, it can expose methods like upload, download, delete, etc., through the portable Layer. Characteristics of an ideal portable Layer: . | The portable Layer should be substrate-agnostic, containing no substrate-specific logic. It should offer a substrate-agnostic experience for the end user. | The portable Layer should accept the substrate(provider) value from the end user and initiate the appropriate session on that substrate. (We might consider that empty provider will pick whatever provider it finds first in the classpath, if required). | The portable Layer should allow users to provide substrate-agnostic inputs such as region name, credentials through a credentials provider defined in Substrate SDK, bucket name (for blob services), etc. | The portable Layer should only expose functions that are supported across all substrates. It should not support or expose features that work on one substrate but not on others. | The portable Layer should strive to provide the best experience for the end user, requiring as little information as possible. | . Example usage of the portable Layer for blob storage and uploading the blob: . // hardcodes for illustration purposes values should be outside of the service code String substrate = \"aws\" String region = \"us-east-1\" // Setting up session credentials - // these are optional and ideally in prod, this is not required // since the k8s pods are set with default credentials and Substrate SDK // uses the default credentials in that case. StsCredentials credentials = new StsCredentials( \"accessKeyId\", \"accessKeySecret\", \"sessionToken\"); CredentialsOverrider credsOverrider = new CredentialsOverrider .Builder(CredentialsType.SESSION).withSessionCredentials(credentials).build(); // Initiate the substrate agnostic BucketClient BucketClient client = BucketClient.builder(substrate) .withBucket(\"chameleon-java\") .withRegion(region) .withCredentialsOverrider(credsOverrider).build(); // Prepare the substrate agnostic UploadRequest UploadRequest uploadRequest = new UploadRequest.Builder() .withKey(\"bucket-path/chameleon.jpg\") // Upload the content UploadResponse response = client.upload(uploadRequest, \"dummy-content\"); . The above example demonstrates that the end user wants to open the client for the blob storage in the AWS substrate to the bucket ‚Äúchameleon-java‚Äù in the region ‚Äúus-east-1‚Äù. The client is used to upload/write the blob in the bucket. In this example, the portable fulfills all the requirements as discussed above: . | There is no substrate specific logic exposed on the portable Layer. From the code block, there is no substrate specific exposure and this logic works in the same manner for other substrates by just providing a different substrate value. | portable Layer forces the client the provide a substrate value, it doesn‚Äôt assume or interpret the substrate based on the runtime. | It provides a way to supply inputs to open the session in a substrate agnostic manner. | It asks the minimum amount of information from the end user without knowing the internals of the SDK. | . ",
    "url": "/multicloudj/design/layers.html#portable-layer",
    
    "relUrl": "/design/layers.html#portable-layer"
  },"54": {
    "doc": "Layers",
    "title": "Driver Layer",
    "content": "The driver layer is a layer behind the portable Layer which defines the abstract functions and implementations for each substrate/provider. The driver layer can also include wrapper logic on top of abstract functions to further simplify portable Layer. Structure . The basic structure of abstract Blob Store looks like this which defines some variables required for the provider implementation such as region and the provider id: . public abstract class AbstracBlobtore { protected final String providerId; protected final String region; protected final String bucket; // Abstract methods for substrate-specific implementations protected abstract UploadResponse doUpload(UploadRequest uploadRequest); protected abstract DownloadResponse doDownload(DownloadRequest downloadRequest); protected abstract void doDelete(String key); } . Why do need a separate driver layer? . While it‚Äôs possible to achieve the abstraction of service capabilities without this driver layer and instead make the portable layer an abstract class, there are numerous benefits to keeping the portable layer separate. These benefits include: . Separation of concerns: . Abstract classes deal with internal code of SDK and abstract methods for providers to implement where as portable Layer or client is all about external facing code. We can keep the portable Layer light weight and to the point. Driver abstraction consist of: . | Common methods for logic which applies to all providers | Abstract methods to be implemented by providers | . Prevention of leaky abstractions: . Having a separate portable Layer prevents the leaky abstractions because the client doesn‚Äôt have to deal with or access the driver layer which might expose some internals. Maintainability: . Changing the internal implementations are comparatively safe without breaking portable Layer contracts. Testing: . End users have simple portable layer for mocks and testing. Example: . For instance, the upload method in BucketClient have multiple methods in the backend, such as validateContent to validate if the content is in the right format which is common for all providers. This validateContent method should be internal and not exposed to end users, therefore it can be part of driver layer and keep the BucketClient purely public. Secondly, if we have a prepContent abstraction function in driver which should be implemented by all the provider implementations to prepareContent for specific substrate. Now, let‚Äôs say each substrate appends the content with some prefix bytes which are substrate specific. So the upload method is executed as follow behind the scenes: . public UploadResponse upload(UploadRequest uploadRequest) { validation(); &lt;- this is common validation for all substrates prepContent(); &lt;- this is provider specific prep content doUpload(); this is provider specific upload of the content } . Basically we might have several methods which the end user doesn‚Äôt care about and should be completely abstracted from the users. These functions should be placed in driver layer, keeping the portable layer purely public and sanitized. ",
    "url": "/multicloudj/design/layers.html#driver-layer",
    
    "relUrl": "/design/layers.html#driver-layer"
  },"55": {
    "doc": "Layers",
    "title": "Provider Layer",
    "content": "Provider layer implements the driver layer for each substrate. Provider layer is for each provider or substrate which powers the API calls from the end users to make substrate specific calls. In the below code example: AWSBlobStore is the provider for blob/blobstore for AWS substrate and implements all the abstract functions in the AWS substrate. public class AWSBlobStore extends AbstractBlobStore { S3Client s3Client; public AWSBlobStore(Builder builder) { s3Client = ... // code logic to build the s3Client by information from builder } @Override protected void doUploadFile(String key, String filePath) { Map&lt;String, String&gt; metadata = new HashMap&lt;&gt;(); PutObjectRequest putOb = PutObjectRequest.builder() .bucket(this.bucketName) .key(key) .metadata(metadata) .build(); s3Client.putObject(putOb, RequestBody.fromFile(new File(filePath))); log.info(\"Successfully placed object\" + \" into bucket \" + bucketName); } @Override public Builder builder() { return new Builder(); } public static class Builder extends AbstractBlobStore.Builder&lt;AwsBlobStore&gt; { public Builder() { providerId(\"aws\"); } @Override public AwsBlobStore build() { return new AwsBlobStore(this); } ... } } . ",
    "url": "/multicloudj/design/layers.html#provider-layer",
    
    "relUrl": "/design/layers.html#provider-layer"
  },"56": {
    "doc": "Layers",
    "title": "Best Practices",
    "content": ". | Keep the Portable Layer Clean . | Only expose substrate-agnostic APIs | Validate inputs before passing to driver layer | Handle common error cases | . | Driver Layer Design . | Define clear interfaces | Include common validation logic | Provide default implementations where possible | Document expected behavior | . | Provider Implementation . | Follow the driver layer contract strictly | Handle provider-specific edge cases | Implement proper error handling | Add provider-specific logging | . | . ",
    "url": "/multicloudj/design/layers.html#best-practices",
    
    "relUrl": "/design/layers.html#best-practices"
  },"57": {
    "doc": "Layers",
    "title": "Common Pitfalls",
    "content": ". | Leaky Abstractions . | Avoid exposing provider-specific types in the portable layer | Don‚Äôt let provider-specific exceptions bubble up | Keep provider-specific configuration internal | . | Inconsistent Behavior . | Ensure all providers implement the same behavior | Handle edge cases consistently | Document any provider-specific limitations | . | Performance Issues . | Avoid unnecessary abstraction layers | Cache provider clients when possible | Use efficient data structures | . | . ",
    "url": "/multicloudj/design/layers.html#common-pitfalls",
    
    "relUrl": "/design/layers.html#common-pitfalls"
  },"58": {
    "doc": "How to STS",
    "title": "STS (Security Token Service)",
    "content": "The StsClient class in the multicloudj library provides a portable interface for interacting with cloud provider security token services such as AWS STS, GCP IAM Credentials, or any other compatible implementation. It allows you to obtain temporary credentials, access tokens, and caller identity information in a cloud-neutral way. ",
    "url": "/multicloudj/guides/sts-guide.html#sts-security-token-service",
    
    "relUrl": "/guides/sts-guide.html#sts-security-token-service"
  },"59": {
    "doc": "How to STS",
    "title": "Overview",
    "content": "The StsClient is built on top of provider-specific implementations of AbstractSts. Each provider registers its implementation and is selected dynamically at runtime. ",
    "url": "/multicloudj/guides/sts-guide.html#overview",
    
    "relUrl": "/guides/sts-guide.html#overview"
  },"60": {
    "doc": "How to STS",
    "title": "Feature Support Across Providers",
    "content": "Core API Features . | Feature Name | GCP | AWS | ALI | Comments | . | Assume Role | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Core feature for temporary credentials for role/service account | . | Get Caller Identity | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Returns identity information of the current caller | . | Get Access Token | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Get credentials using default env configs | . Configuration Options . | Configuration | GCP | AWS | ALI | Comments | . | Region Support | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | All providers support region-specific operations | . | Endpoint Override | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Custom endpoint configuration | . Provider-Specific Notes . GCP (Google Cloud Platform) . | Uses Google‚Äôs OAuth 2.0 access tokens for credentials and ID tokens for Caller Identity | . ",
    "url": "/multicloudj/guides/sts-guide.html#feature-support-across-providers",
    
    "relUrl": "/guides/sts-guide.html#feature-support-across-providers"
  },"61": {
    "doc": "How to STS",
    "title": "Creating a Client",
    "content": "StsClient stsClient = StsClient.builder(\"aws\") .withRegion(\"us-west-2\") .build(); . Optionally, you can set a custom endpoint: . URI endpoint = URI.create(\"https://sts.custom-endpoint.com\"); StsClient stsClient = StsClient.builder(\"aws\") .withRegion(\"us-west-2\") .withEndpoint(endpoint) .build(); . ",
    "url": "/multicloudj/guides/sts-guide.html#creating-a-client",
    
    "relUrl": "/guides/sts-guide.html#creating-a-client"
  },"62": {
    "doc": "How to STS",
    "title": "Getting Caller Identity",
    "content": "Retrieve the caller identity associated with the current credentials: . CallerIdentity identity = stsClient.getCallerIdentity(); System.out.println(\"Caller: \" + identity.getArn()); . ",
    "url": "/multicloudj/guides/sts-guide.html#getting-caller-identity",
    
    "relUrl": "/guides/sts-guide.html#getting-caller-identity"
  },"63": {
    "doc": "How to STS",
    "title": "Getting an Access Token",
    "content": "Use this when you need an OAuth2-style token (provider support may vary): . GetAccessTokenRequest request = new GetAccessTokenRequest(); StsCredentials token = stsClient.getAccessToken(request); System.out.println(\"Access Token: \" + token.getAccessToken()); . ",
    "url": "/multicloudj/guides/sts-guide.html#getting-an-access-token",
    
    "relUrl": "/guides/sts-guide.html#getting-an-access-token"
  },"64": {
    "doc": "How to STS",
    "title": "Assuming a Role",
    "content": "To assume a different identity (e.g., for cross-account access): . AssumedRoleRequest request = new AssumedRoleRequest(); request.setRoleArn(\"arn:aws:iam::123456789012:role/example-role\"); request.setSessionName(\"example-session\"); StsCredentials credentials = stsClient.getAssumeRoleCredentials(request); System.out.println(\"Temporary Credentials: \" + credentials.getAccessKeyId()); . ",
    "url": "/multicloudj/guides/sts-guide.html#assuming-a-role",
    
    "relUrl": "/guides/sts-guide.html#assuming-a-role"
  },"65": {
    "doc": "How to STS",
    "title": "Error Handling",
    "content": "All errors are translated to SubstrateSdkException subclasses by the underlying driver. The client will automatically map exceptions to meaningful runtime errors based on the provider: . try { CallerIdentity identity = stsClient.getCallerIdentity(); } catch (SubstrateSdkException e) { // Handle known errors: AccessDenied, Timeout, etc. e.printStackTrace(); } . ",
    "url": "/multicloudj/guides/sts-guide.html#error-handling",
    
    "relUrl": "/guides/sts-guide.html#error-handling"
  },"66": {
    "doc": "How to STS",
    "title": "How to STS",
    "content": " ",
    "url": "/multicloudj/guides/sts-guide.html",
    
    "relUrl": "/guides/sts-guide.html"
  }
}
