{"0": {
    "doc": "Api Documentation",
    "title": "Java API documentation of the SDK",
    "content": " ",
    "url": "/multicloudj/api-java-doc.html#java-api-documentation-of-the-sdk",
    
    "relUrl": "/api-java-doc.html#java-api-documentation-of-the-sdk"
  },"1": {
    "doc": "Api Documentation",
    "title": "Api Documentation",
    "content": "Java doc link for MultiCloudJ . ",
    "url": "/multicloudj/api-java-doc.html",
    
    "relUrl": "/api-java-doc.html"
  },"2": {
    "doc": "How to Blob store",
    "title": "BucketClient",
    "content": "The BucketClient class in the multicloudj library provides a comprehensive, cloud-agnostic interface to interact with individual buckets in object storage services like AWS S3, Azure Blob Storage, and Google Cloud Storage. This client enables uploading, downloading, deleting, listing, copying, and managing blob metadata and multipart uploads across multiple cloud providers. ",
    "url": "/multicloudj/guides/blobstore-guide.html#bucketclient",
    
    "relUrl": "/guides/blobstore-guide.html#bucketclient"
  },"3": {
    "doc": "How to Blob store",
    "title": "Feature Support Across Providers",
    "content": "Core API Features . | Feature Name | GCP | AWS | ALI | Comments | . | Basic Upload | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Upload from InputStream, byte[], File, Path | . | Basic Download | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Download to OutputStream, byte[], File, Path | . | Delete Objects | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Single and batch delete operations | . | Copy Objects | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Server-side copy within and across buckets | . | Get Metadata | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Retrieve object metadata and properties | . | List Objects | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Paginated listing with filters | . | Object Tagging | ‚è±Ô∏è End of July‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Get and set object tags | . | Presigned URLs | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Generate temporary access URLs | . | Versioning Support | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Object version-specific operations | . Multipart Upload Features . | Feature Name | GCP | AWS | ALI | Comments | . | Initiate Multipart | Ô∏è Mid of Aug‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Start multipart upload session | . | Upload Part | Mid of Aug‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Upload individual parts | . | Complete Multipart | Mid of Aug‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Finalize multipart upload | . | List Parts | Mid of Aug‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | List uploaded parts | . | Abort Multipart | Mid of Aug‚Äô25 | ‚úÖ Supported | ‚úÖ Supported | Cancel multipart upload | . Advanced Features . | Feature Name | GCP | AWS | ALI | Comments | . | Async Operations | ‚úÖ Supported | ‚úÖ Supported | üìÖ In Roadmap | CompletableFuture-based async API available only for AWS | . | Bucket Operations | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | List buckets via BlobClient | . Configuration Options . | Configuration | GCP | AWS | ALI | Comments | . | Endpoint Override | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Custom endpoint configuration | . | Proxy Support | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | HTTP proxy configuration | . | Credentials Override | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Custom credential providers via STS | . Provider-Specific Notes . ",
    "url": "/multicloudj/guides/blobstore-guide.html#feature-support-across-providers",
    
    "relUrl": "/guides/blobstore-guide.html#feature-support-across-providers"
  },"4": {
    "doc": "How to Blob store",
    "title": "Creating a Client",
    "content": "BucketClient bucketClient = BucketClient.builder(\"aws\") .withRegion(\"us-west-2\") .withBucket(\"my-bucket\") .build(); . You can also configure advanced options: . URI endpoint = URI.create(\"https://custom-endpoint.com\"); URI proxy = URI.create(\"https://proxy.example.com\"); bucketClient = BucketClient.builder(\"aws\") .withRegion(\"us-west-2\") .withBucket(\"my-bucket\") .withEndpoint(endpoint) .withProxyEndpoint(proxy) .build(); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#creating-a-client",
    
    "relUrl": "/guides/blobstore-guide.html#creating-a-client"
  },"5": {
    "doc": "How to Blob store",
    "title": "Uploading Files",
    "content": "Supports various sources: . UploadRequest request = new UploadRequest(\"object-key\"); bucketClient.upload(request, inputStream); bucketClient.upload(request, new File(\"file.txt\")); bucketClient.upload(request, path); bucketClient.upload(request, byteArray); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#uploading-files",
    
    "relUrl": "/guides/blobstore-guide.html#uploading-files"
  },"6": {
    "doc": "How to Blob store",
    "title": "Downloading Files",
    "content": "DownloadRequest request = new DownloadRequest(\"object-key\"); bucketClient.download(request, outputStream); bucketClient.download(request, new File(\"dest.txt\")); bucketClient.download(request, path); bucketClient.download(request, byteArray); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#downloading-files",
    
    "relUrl": "/guides/blobstore-guide.html#downloading-files"
  },"7": {
    "doc": "How to Blob store",
    "title": "Listing Blobs",
    "content": "ListBlobsRequest request = new ListBlobsRequest(); Iterator&lt;BlobInfo&gt; blobs = bucketClient.list(request); while (blobs.hasNext()) { System.out.println(blobs.next().getName()); } . ",
    "url": "/multicloudj/guides/blobstore-guide.html#listing-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#listing-blobs"
  },"8": {
    "doc": "How to Blob store",
    "title": "Deleting Blobs",
    "content": "bucketClient.delete(\"object-key\", null); // optional versionId Collection&lt;BlobIdentifier&gt; toDelete = List.of( new BlobIdentifier(\"object1\"), new BlobIdentifier(\"object2\") ); bucketClient.delete(toDelete); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#deleting-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#deleting-blobs"
  },"9": {
    "doc": "How to Blob store",
    "title": "Copying Blobs",
    "content": "CopyRequest copyRequest = new CopyRequest(); // populate source and destination CopyResponse response = bucketClient.copy(copyRequest); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#copying-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#copying-blobs"
  },"10": {
    "doc": "How to Blob store",
    "title": "Metadata and Tags",
    "content": "BlobMetadata metadata = bucketClient.getMetadata(\"object-key\", null); Map&lt;String, String&gt; tags = bucketClient.getTags(\"object-key\"); bucketClient.setTags(\"object-key\", Map.of(\"env\", \"prod\")); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#metadata-and-tags",
    
    "relUrl": "/guides/blobstore-guide.html#metadata-and-tags"
  },"11": {
    "doc": "How to Blob store",
    "title": "Presigned URLs",
    "content": "PresignedUrlRequest presignedRequest = new PresignedUrlRequest(); URL url = bucketClient.generatePresignedUrl(presignedRequest); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#presigned-urls",
    
    "relUrl": "/guides/blobstore-guide.html#presigned-urls"
  },"12": {
    "doc": "How to Blob store",
    "title": "Multipart Uploads",
    "content": "MultipartUploadRequest initRequest = new MultipartUploadRequest(); MultipartUpload upload = bucketClient.initiateMultipartUpload(initRequest); UploadPartResponse part = bucketClient.uploadMultipartPart(upload, partData); List&lt;UploadPartResponse&gt; parts = List.of(part1, part2); bucketClient.completeMultipartUpload(upload, parts); List&lt;UploadPartResponse&gt; uploadedParts = bucketClient.listMultipartUpload(upload); bucketClient.abortMultipartUpload(upload); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#multipart-uploads",
    
    "relUrl": "/guides/blobstore-guide.html#multipart-uploads"
  },"13": {
    "doc": "How to Blob store",
    "title": "Error Handling",
    "content": "All operations may throw SubstrateSdkException. These can be caught and handled generically: . try { bucketClient.upload(request, new File(\"file.txt\")); } catch (SubstrateSdkException e) { // Handle access denied, IO failure, etc. e.printStackTrace(); } . Use BucketClient when you need full CRUD support and advanced control over blobs inside a single bucket, across any supported cloud provider. ",
    "url": "/multicloudj/guides/blobstore-guide.html#error-handling",
    
    "relUrl": "/guides/blobstore-guide.html#error-handling"
  },"14": {
    "doc": "How to Blob store",
    "title": "How to Blob store",
    "content": " ",
    "url": "/multicloudj/guides/blobstore-guide.html",
    
    "relUrl": "/guides/blobstore-guide.html"
  },"15": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "How to: Conformance tests in multicloud",
    "content": "This document is to help you write the conformance tests (can be aka integration tests) for multicloudj using wiremock to record and replay the cloud service calls. ",
    "url": "/multicloudj/guides/conformance-tests-guide.html#how-to-conformance-tests-in-multicloud",
    
    "relUrl": "/guides/conformance-tests-guide.html#how-to-conformance-tests-in-multicloud"
  },"16": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "Overview",
    "content": "Conformance tests are very powerful to validate the SDK for multi-cloud environments where all the provider implementation satisfy the common abstractions. | Conformance tests are written once at the abstract level and all the provider implementations supply the substrate specific details such as resource names to execute the tests for that cloud provider. | Conformance tests can be executed in the offline mode where it‚Äôs challenging to get real time network connectivity from a single source to multiple cloud providers. | . Conformance tests can run in two modes: . | Record mode: where the tests hit the real service endpoint and transactions get intercepted by proxy and recorded in the files. | Replay mode: where the tests get the replayed responses from the previously recorded transactions. | . ",
    "url": "/multicloudj/guides/conformance-tests-guide.html#overview",
    
    "relUrl": "/guides/conformance-tests-guide.html#overview"
  },"17": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "Wiremock as a forward proxy",
    "content": "To intercept the tests in record mode, we use wiremock server as forward proxy which has the ability the record the transactions and replay it later. SDK client to wiremock doesn‚Äôt matter much for security because everything is local, therefore we configure the SDK clients to trust all the certs which includes the wiremock self signed cert presented to the SDK client. We can also have that layer to http as well. ",
    "url": "/multicloudj/guides/conformance-tests-guide.html#wiremock-as-a-forward-proxy",
    
    "relUrl": "/guides/conformance-tests-guide.html#wiremock-as-a-forward-proxy"
  },"18": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "How to configure the SDK to proxy through wiremock",
    "content": "In order to utilize the record/replay mode through wiremock there are two most common ways provide the SDKs: . Override the http client in SDK (preferred) . You should be able to override the http client in SDK client and your http client should have the proxy configured to wiremock. AWS example: You can create the custom http client for AWS (code ref) and inject in into the SDK client. Ali example: You can create the httpclient config (code ref) for the client profile and inject it in the SDK client (code ref). Environment Variables . Some SDKs support reading the HTTPS_PROXY, HTTP_PROXY environment variables if set and direct the API call through the proxy. Examples from Alibaba tablestore here. If your SDK is not re-using any of the existing patterns already in the conformance tests, it might take some research on how to inject the custom client. ",
    "url": "/multicloudj/guides/conformance-tests-guide.html#how-to-configure-the-sdk-to-proxy-through-wiremock",
    
    "relUrl": "/guides/conformance-tests-guide.html#how-to-configure-the-sdk-to-proxy-through-wiremock"
  },"19": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "How to run the Java SDK conformance tests for alibaba",
    "content": "Steps: . | Get the alibaba credentials for authenticating to service as admin preferably unless you want to deal with role based access: . acs-sso login --env . | Go to your GoLand IDE: . | Run ‚Üí Edit Configurations ‚Üí Environment. Add the above credentials in the environment: ALICLOUD_ACCESS_KEY, ALICLOUD_SECRET_KEY and ALICLOUD_SECURITY_TOKEN . | For docstore: the env variables are: TABLESTORE_ACCESS_KEY_ID, TABLESTORE_ACCESS_KEY_SECRET and TABLESTORE_SESSION_TOKEN | . | In the arguments, add -Drecord | . | You should be all set to run the tests in record mode. | In order to run your tests in replay mode, just remove -Drecord from Program arguments. Your tests will stop going across the network and will replay from recorded files. | . ",
    "url": "/multicloudj/guides/conformance-tests-guide.html#how-to-run-the-java-sdk-conformance-tests-for-alibaba",
    
    "relUrl": "/guides/conformance-tests-guide.html#how-to-run-the-java-sdk-conformance-tests-for-alibaba"
  },"20": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "How to set up the google cloud credentials in IDE",
    "content": ". | Login to the gcloud from cli: gcloud auth application-default login . | Recommended (impersonate the service account and grant all the permissions required to this SA): gcloud config set auth/impersonate_service_account $SA_EMAIL . | Set the GOOGLE_APPLICATION_CREDENTIALS environment variable pointing to the file with gcp credentials: GOOGLE_APPLICATION_CREDENTIALS=/Users/&lt;username&gt;/.config/gcloud/application_default_credentials.json . | . ",
    "url": "/multicloudj/guides/conformance-tests-guide.html#how-to-set-up-the-google-cloud-credentials-in-ide",
    
    "relUrl": "/guides/conformance-tests-guide.html#how-to-set-up-the-google-cloud-credentials-in-ide"
  },"21": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "How to run the record mode",
    "content": "The tests are configured to take the java system property -Drecord which will do the recording of the transactions. In intellij for bazel, you can setup this property through Run configurations. Note for Bazel . When running in bazel, your recording path need to be set temporarily to outside the resources directory, and later copied to the resources directory for the module (for example: sts-aws resources directory) once you are done recording. The reason for this is the bazel executing tests in the temporary directory and not the actual path. If you don‚Äôt override the recording location, your recordings will be located in that temporary directory for bazel. Tip: You can setup the root directory to /tmp which doesn‚Äôt need any special write permissions for bazel. Once you run the tests, you should be able to see the /tmp/mappings directory for the recordings. The equivalent of -Drecord in bazel will be --jvmopt=\"-Drecord\" . Reference command to copy the mappings to bazel path: . cp -r /tmp/mappings /Users/$relativePath/multicloudj/docstore/docstore-aws/src/test/resources/ . Note for alibaba SDK . Alibaba SDK puts all the secret and dynamic information such as security token, in the URL query params itself instead of headers. This dynamic information creates the problem with replaying because of dynamic nature since the the replayer won‚Äôt be able to find the match with mappings. Wiremock doesn‚Äôt provide any clean way to redact the information in the URL. Thus we have to manually change the recorded URL to URL pattern and replace the dynamic information with the wildcards: . For example: . We change the dynamic information to .* and changed the key from url to urlPattern: . \"urlPattern\" : \"/\\\\?SecurityToken=.*&amp;SignatureVersion=1.0&amp;Action=GetCallerIdentity&amp;Format=JSON&amp;SignatureNonce=.*&amp;Version=2015-04-01&amp;AccessKeyId=.*&amp;Signature=.*&amp;SignatureMethod=HMAC-SHA1&amp;RegionId=cn-shanghai&amp;Timestamp=.*\" . ",
    "url": "/multicloudj/guides/conformance-tests-guide.html#how-to-run-the-record-mode",
    
    "relUrl": "/guides/conformance-tests-guide.html#how-to-run-the-record-mode"
  },"22": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "How to run the replay mode",
    "content": "If you don‚Äôt set up the -Drecord in the jvmopt, by default the test will run the replay mode and looks for the mappings in the root directory for wiremock. ",
    "url": "/multicloudj/guides/conformance-tests-guide.html#how-to-run-the-replay-mode",
    
    "relUrl": "/guides/conformance-tests-guide.html#how-to-run-the-replay-mode"
  },"23": {
    "doc": "How to: Conformance tests in multicloudj",
    "title": "How to: Conformance tests in multicloudj",
    "content": " ",
    "url": "/multicloudj/guides/conformance-tests-guide.html",
    
    "relUrl": "/guides/conformance-tests-guide.html"
  },"24": {
    "doc": "How to Docstore",
    "title": "Docstore",
    "content": "The DocStoreClient class in the multicloudj library provides a portable document store like abstraction over NoSQSL database providers like Amazon DynamoDB, Alibaba Tablestore, and Google Firestore. It supports core document operations like create, read, update, delete (CRUD), batching, and querying with the support of indexing. Internally, each provider is implemented via a driver extending AbstractDocStore. ",
    "url": "/multicloudj/guides/docstore-guide.html#docstore",
    
    "relUrl": "/guides/docstore-guide.html#docstore"
  },"25": {
    "doc": "How to Docstore",
    "title": "Feature Support Across Providers",
    "content": "Core API Features . | Feature Name | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Create Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Insert new documents | . | Get Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Get the document by key | . | Put Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Insert or replace document | . | Replace Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Replace existing document | . | Delete Document | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Remove document by key | . | Update Document | ‚è±Ô∏è Coming Soon | ‚è±Ô∏è Coming Soon | ‚è±Ô∏è Coming Soon | Update operations not yet implemented in any provider | . Batch Operations . | Feature Name | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Batch Get | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Retrieve multiple documents in one call | . | Batch Write | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Write multiple documents atomically | . | Atommic Writes | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Atomic write operations across multiple documents | . Query Features . | Feature Name | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Basic Queries | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Filter and projection queries | . | Compound Filters | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Multiple filter conditions | . | Order By | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Sort query results | . | Order By in Full Scan | ‚ùå Not Supported | ‚ùå Not Supported | ‚ùå Not Supported | ** It‚Äôs too expensive ** | . | Pagination Token | ‚úÖ Supported | ‚úÖ Supported | üìÖ In Roadmap | Query with pagination | . | Limit/Offset | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Pagination support | . | Index-based Queries | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Query using secondary indexes | . | Query Planning | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Explain query execution plans | . Advanced Features . | Feature Name | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Revision/Versioning | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Optimistic concurrency control | . | Single Key Collections | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Collections with only partition key | . | Two Key Collections | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Collections with partition + sort key(uses indexes in firestore) | . Configuration Options . | Configuration | GCP Firestore | AWS DynamoDB | ALI Tablestore | Comments | . | Regional Support | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Region-specific operations | . | Custom Endpoints | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Override default service endpoints | . | Credentials Override | ‚úÖ Supported | ‚úÖ Supported | üìÖ In Roadmap | Custom credential providers via STS | . | Collection Options | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Table/collection configuration | . Important Notes about semantics: . | If you are using in-equality filters (&lt;, &gt;, &lt;=, &gt;=) in query, make sure to put an order by on the same fields to get the consistent results. This is the limitation from gcp firestore (ref). | Nested Maps, List types are not supported in Alibaba. If your service is targeting alibaba as well, please consider serializing it yourself for this use-case. | Atomic writes doesn‚Äôt support global transaction (across partition keys) across alibaba. | . ",
    "url": "/multicloudj/guides/docstore-guide.html#feature-support-across-providers",
    
    "relUrl": "/guides/docstore-guide.html#feature-support-across-providers"
  },"26": {
    "doc": "How to Docstore",
    "title": "Creating a Client",
    "content": "To begin using DocStoreClient, use the static builder: . CollectionOptions collectionOptions = new CollectionOptions.CollectionOptionsBuilder() .withTableName(\"chameleon-test\") .withPartitionKey(\"pName\") .withSortKey(\"s\") .withRevisionField(\"docRevision\") .build(); DocStoreClient client = DocStoreClient.builder(\"aws\") .withRegion(\"us-west-2\") .withCollectionOptions(collectionOptions) .build(); . ",
    "url": "/multicloudj/guides/docstore-guide.html#creating-a-client",
    
    "relUrl": "/guides/docstore-guide.html#creating-a-client"
  },"27": {
    "doc": "How to Docstore",
    "title": "Document Representation",
    "content": "The Document class accepts either a user-defined class or a generic map. Option 1: Using a POJO (Player) . @AllArgsConstructor @NoArgsConstructor @Data public class Player { private String pName; private int i; private float f; private boolean b; private String s; } Player player = new Player(\"Alice\", 42, 99.5f, true, \"metadata\"); Document doc = new Document(player); . Option 2: Using a HashMap . Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"pName\", \"Alice\"); map.put(\"i\", 42); map.put(\"f\", 99.5f); map.put(\"b\", true); map.put(\"s\", \"metadata\"); Document doc = new Document(map); . ",
    "url": "/multicloudj/guides/docstore-guide.html#document-representation",
    
    "relUrl": "/guides/docstore-guide.html#document-representation"
  },"28": {
    "doc": "How to Docstore",
    "title": "Actions",
    "content": "Once you have initialized a docstore client, you can call action methods on it to read, modify, and write documents. These are referred to as actions, and can be executed individually or as part of a batch using an action list. DocStore supports the following types of actions: . | Get retrieves a document. | Create creates a new document. | Replace replaces an existing document. | Put puts a document whether or not it already exists. | Update applies modifications to a document (not supported yet). | Delete deletes a document. | . Each of the following examples illustrates one of these actions. ",
    "url": "/multicloudj/guides/docstore-guide.html#actions",
    
    "relUrl": "/guides/docstore-guide.html#actions"
  },"29": {
    "doc": "How to Docstore",
    "title": "Basic Operations",
    "content": "Create . Create will throw an exception ResourceAlreadyExists if the document already exists. client.create(doc); . Get . To retrieve a document, you must provide a Document initialized with the corresponding object and pre-populate the fields that uniquely identify it (e.g., partition key and sort key): . Player player = new Player(); player.setPName(\"Alice\"); // Assuming pName is the partition key player.setS(\"metadata\"); // Assuming s is the sort key client.get(new Document(player)); . With optional fields you want to retrieve: . client.get(new Document(player), \"pName\", \"f\"); . Replace . Replaces the existing doc, will throw ResourceNotFound is the document doesn‚Äôt exist. client.replace(doc); . Put . Put is similar to create but will not throw in case the document doesn‚Äôt exist. client.put(doc); . Delete . To delete a document, the input must also have the required key fields populated: . Player player = new Player(); player.setPName(\"Alice\"); player.setS(\"metadata\"); client.delete(new Document(player)); . Update (Not Supported) . client.update(doc, Map.of(\"f\", 120.0f)); // Throws UnSupportedOperationException . ",
    "url": "/multicloudj/guides/docstore-guide.html#basic-operations",
    
    "relUrl": "/guides/docstore-guide.html#basic-operations"
  },"30": {
    "doc": "How to Docstore",
    "title": "Batch Operations",
    "content": "Batch Get . List&lt;Document&gt; docs = List.of( new Document().put(\"pName\", \"Alice\").put(\"s\", \"metadata\"), new Document().put(\"pName\", \"Bob\").put(\"s\", \"stats\") ); client.batchGet(docs); . Batch Put . List&lt;Document&gt; docs = List.of( new Document().put(\"pName\", \"Alice\").put(\"f\", 10.5f), new Document().put(\"pName\", \"Bob\").put(\"f\", 20.0f) ); client.batchPut(docs); . ",
    "url": "/multicloudj/guides/docstore-guide.html#batch-operations-1",
    
    "relUrl": "/guides/docstore-guide.html#batch-operations-1"
  },"31": {
    "doc": "How to Docstore",
    "title": "Queries",
    "content": "DocStore‚Äôs get action retrieves a single document by its primary key. However, when you need to retrieve or manipulate multiple documents that match a condition, you can use queries. Queries allow you to: . | Retrieve all documents that match specific conditions. | Delete or update documents in bulk based on criteria. | . The query interface is chainable and supports filtering and sorting (depending on driver support). DocStore can also optimize queries automatically. Based on your filter conditions, it attempts to determine whether a global secondary index (GSI) or a local secondary index (LSI) can be used to execute the query more efficiently. This helps reduce latency and improves performance. Queries support the following methods: . | Where: Describes a condition on a document. You can ask whether a field is equal to, greater than, or less than a value. The ‚Äúnot equals‚Äù comparison isn‚Äôt supported, because it isn‚Äôt portable across providers. | OrderBy: Specifies the order of the resulting documents, by field and direction. For portability, you can specify at most one OrderBy, and its field must also be mentioned in a Where clause. | Limit: Limits the number of documents in the result. | . Query query = client.query(); // Apply filtering, sorting, etc. (Depends on driver implementation.) . ",
    "url": "/multicloudj/guides/docstore-guide.html#queries",
    
    "relUrl": "/guides/docstore-guide.html#queries"
  },"32": {
    "doc": "How to Docstore",
    "title": "Advanced Usage",
    "content": "Action Lists . ActionList actions = client.getActions(); actions.put(doc1).get(doc2).delete(doc3); actions.run(); . You can also chain operations directly using the fluent API with enableAtomicWrites() for atomic execution: . client.getActions() .create(new Document(new Player(\"Alice\", 1, 3.99f, true, \"CA\"))) .create(new Document(new Player(\"Bob\", 2, 3.99f, true, \"PT\"))) .create(new Document(new Player(\"Carol\", 3, 3.99f, true, \"PA\"))) .enableAtomicWrites() .create(new Document(new Player(\"Dave\", 4, 3.99f, true, \"TX\"))) .create(new Document(new Player(\"Eve\", 5, 3.99f, true, \"OR\"))) .create(new Document(new Player(\"Frank\", 6, 3.99f, true, \"NJ\"))) .run(); . Atomic Writes: . If you want to write your documents atomically, just use the enableAtomicWrites as above and all the writes are this will be executed atomically. Close the Client . client.close(); . ",
    "url": "/multicloudj/guides/docstore-guide.html#advanced-usage",
    
    "relUrl": "/guides/docstore-guide.html#advanced-usage"
  },"33": {
    "doc": "How to Docstore",
    "title": "How to Docstore",
    "content": " ",
    "url": "/multicloudj/guides/docstore-guide.html",
    
    "relUrl": "/guides/docstore-guide.html"
  },"34": {
    "doc": "Exception Handling",
    "title": "Exception Handling in Substrate SDK",
    "content": " ",
    "url": "/multicloudj/design/errors.html#exception-handling-in-substrate-sdk",
    
    "relUrl": "/design/errors.html#exception-handling-in-substrate-sdk"
  },"35": {
    "doc": "Exception Handling",
    "title": "How Does Exception Handling Work for SDK Users?",
    "content": "Substrate SDK defines substrate-agnostic exceptions for end users, so they don‚Äôt have to deal with substrate-specific exceptions directly. The SDK wraps all exceptions from cloud providers in a standardized wrapper based on the exception type before propagating it to the end user. Some broadly categorized exceptions include: . | SubstrateSdkException ‚Äì&gt; Base class for all the exceptions | AccessDeniedException | ResourceNotFoundException | ResourceAlreadyExistsException | ResourceExhaustedException | InvalidArgumentException | FailedPreConditionException | DeadlineExceededException | ResourceConflictException | UnAuthorizedException | UnSupportedOperationException | UnknownException ‚Äì&gt; This is used when no predefined mapping exists. Ideally, as the SDK evolves, there should be no occurrences of this exception. | . ",
    "url": "/multicloudj/design/errors.html#how-does-exception-handling-work-for-sdk-users",
    
    "relUrl": "/design/errors.html#how-does-exception-handling-work-for-sdk-users"
  },"36": {
    "doc": "Exception Handling",
    "title": "How Does Exception Handling Work for Provider Implementations?",
    "content": "Handling Server-Side Exceptions . Server-side exceptions are relatively straightforward because provider implementations do not need to process them explicitly. These exceptions are considered RunTimeExceptions, which are thrown to the client layer and wrapped according to the predefined mapping. When Provider Implementations Need to Throw Exceptions . There are cases where provider implementations must throw SubstrateSdkException themselves. Some examples include: . | Input Validation Failures . | If a provider implementation validates input parameters and detects an issue, it can throw an InvalidArgumentException directly. | . | Converting Server-Side Exceptions to Different Semantics . | In some cases, a provider implementation may need to reinterpret server-side exceptions. | Example: In DocStore, the create API expects the item not to exist, while the put API does not have this constraint. If a key already exists, the provider must decide which exception to throw based on the API semantics. | . | . Exception Wrapping . | If the exception is already a subclass of SubstrateSdkException, it is not re-wrapped. | Otherwise, exceptions are wrapped according to predefined mappings to ensure a consistent experience for SDK users. | . ",
    "url": "/multicloudj/design/errors.html#how-does-exception-handling-work-for-provider-implementations",
    
    "relUrl": "/design/errors.html#how-does-exception-handling-work-for-provider-implementations"
  },"37": {
    "doc": "Exception Handling",
    "title": "Exception Handling",
    "content": " ",
    "url": "/multicloudj/design/errors.html",
    
    "relUrl": "/design/errors.html"
  },"38": {
    "doc": "Flexibility",
    "title": "Flexibility",
    "content": "Substrate SDK remains extensible and you can have your custom providers implementing the driver layer and include the provider jar in the classpath. All you need to do is load the provider with providerId, for example: . BucketClient.builder(\"&lt;BlobstoreCustomProvider&gt;\")... DocstoreClient.builder(\"DocstoreCustomProvider\")... You can also keep the providers outside of this SDK repo anywhere as long as they have access to driver layer. There might be few use-case where you want to tweak the implementation provided by Substrate SDK for your special requirements. You can can have your own implementation overriding the the implementation provided by Substrate SDK and provide that in the runtime. ",
    "url": "/multicloudj/design/flexibility.html",
    
    "relUrl": "/design/flexibility.html"
  },"39": {
    "doc": "MultiCloudJ Overview",
    "title": "MultiCloudJ",
    "content": " ",
    "url": "/multicloudj/#multicloudj",
    
    "relUrl": "/#multicloudj"
  },"40": {
    "doc": "MultiCloudJ Overview",
    "title": "Write once, deploy in any cloud‚Ä¶",
    "content": "MultiCloudJ providing unified and vendor-neutral interfaces for commonly used cloud services such as Blob Storage, Document Store, Security Token Service (STS), and more. It enabbles the cloud developers to write applications that can developed once and be deployed to any of the cloud providers. The interfaces are designed in a way that it can support any of the major cloud providers. ",
    "url": "/multicloudj/#write-once-deploy-in-any-cloud",
    
    "relUrl": "/#write-once-deploy-in-any-cloud"
  },"41": {
    "doc": "MultiCloudJ Overview",
    "title": "Key Features",
    "content": "Substrate-Neutral Write once, deploy anywhere. No vendor lock-in or provider-specific code. Currently Supported Cloud Providers Seamlessly work across AWS, Alibaba Cloud, and Google Cloud Platform with a single, consistent API. Additional cloud providers such as Azure can also be potentially supported. Uniform Semantics Common abstractions with unform semantics that work identically across cloud providers. Enterprise Ready Built with security, scalability, and maintainability in mind for production workloads. Extensiblity Built with extensible architecture design to support additional cloud providers in future. Flexiblity Providers flexibility to users to provider their own custom implementation and just have it in the run time. ",
    "url": "/multicloudj/#key-features",
    
    "relUrl": "/#key-features"
  },"42": {
    "doc": "MultiCloudJ Overview",
    "title": "Supported Services",
    "content": "STS (Security Token Service) . Get access credentials using roles, service accounts, and more across all supported cloud providers. Blob Storage . Manage object storage with unified operations for uploading, downloading, listing, and managing blobs. Document Store . Work with document-oriented databases using consistent interfaces for CRUD operations and querying. Additional services such pubsub, secrets, compute are also in roadmap. Getting Started . ",
    "url": "/multicloudj/#supported-services",
    
    "relUrl": "/#supported-services"
  },"43": {
    "doc": "MultiCloudJ Overview",
    "title": "Running Examples",
    "content": "MultiCloudJ includes comprehensive example programs demonstrating how to interact with supported services. Examples are located in the examples directory and cover: . | STS authentication flows | Blob storage operations | Document store CRUD operations | Cross-provider migration scenarios | . ",
    "url": "/multicloudj/#running-examples",
    
    "relUrl": "/#running-examples"
  },"44": {
    "doc": "MultiCloudJ Overview",
    "title": "Where to Go from Here",
    "content": "Documentation and Guides: . | How-to Guides - Step-by-step guides for developers ready to use the SDK | Design Decisions - Architecture and design principles behind the SDK | . API Documentation: . | Java API Documentation (Javadoc) - Complete API reference | . Community and Support: . | GitHub Issues - Report bugs and request features | Discussion Forum - Get help from the community | Contribution Guidelines - Contribute to the project | . Additional Resources: . | MultiCloudJ Homepage - Source code and project information | Release Notes - Latest updates and changes | Examples Repository - Complete working examples | . MultiCloudJ is maintained by the Salesforce MultiCloudJ team and is open source under the Apache License 2.0. ",
    "url": "/multicloudj/#where-to-go-from-here",
    
    "relUrl": "/#where-to-go-from-here"
  },"45": {
    "doc": "MultiCloudJ Overview",
    "title": "MultiCloudJ Overview",
    "content": " ",
    "url": "/multicloudj/",
    
    "relUrl": "/"
  },"46": {
    "doc": "Design",
    "title": "Design Guides",
    "content": "Welcome to the MultiCloudJ Design Guides. This section provides concise, task-focused guides to help you understand the key design decisions behind the SDK. | Layers of the SDK - Understanding the layered architecture | Error Handling - How errors are handled across the SDK | Flexibility - How to extend and customize the SDK | . ",
    "url": "/multicloudj/design/#design-guides",
    
    "relUrl": "/design/#design-guides"
  },"47": {
    "doc": "Design",
    "title": "Core Design Principles",
    "content": "MultiCloudJ is built on several key principles: . | Unified/Cloud Agnostic Interfaces/: Write once, interact across multiple cloud providers without changing your application code. | Extensibility: New cloud providers can be added without modifying existing code. | Flexibility: Easily override the default implementations and inject your own custom implementation in the env. | Simplicity: The API is designed to be intuitive and easy to use. | Uniform Semantics*: SDK provides the uniform semantics to the end user irrespective of the cloud provider. Examples: . | Object Deletion: AWS S3 returns HTTP 200 when deleting a non-existent object, while Google Cloud Storage returns HTTP 404. MultiCloudJ provides consistent semantics, returning either 200 (success) or 400 (error) regardless of the underlying provider. | Pagination: DynamoDB paginated queries return LastEvaluatedKey for continuation, while Google Cloud Firestore doesn‚Äôt provide this field and let the user figure that out using the last document in the page. MultiCloudJ abstracts this complexity and provides a uniform pagination API that works consistently across all providers. | . Note: While MultiCloudJ strives for uniform semantics, certain provider-specific server side features may not be available across all substrates. For example, global transactions are supported in Google Cloud Firestore, Azure Cosmos and AWS DynamoDB but not in Alibaba Cloud TableStore. In such cases, the SDK will throw appropriate exceptions when unsupported features are attempted on providers that don‚Äôt support them. However, these advanced features are rarely required for majority of the use cases. | Reliability: Robust error handling and retry mechanisms ensure reliable operation. | . ",
    "url": "/multicloudj/design/#core-design-principles",
    
    "relUrl": "/design/#core-design-principles"
  },"48": {
    "doc": "Design",
    "title": "Contributing to Design",
    "content": "We welcome contributions to improve MultiCloudJ‚Äôs design. When contributing: . | Follow the established architectural patterns | Document your design decisions | Consider backward compatibility | Test your changes thoroughly | Update relevant documentation | . ",
    "url": "/multicloudj/design/#contributing-to-design",
    
    "relUrl": "/design/#contributing-to-design"
  },"49": {
    "doc": "Design",
    "title": "Design Decisions",
    "content": "Key design decisions in MultiCloudJ include: . | Layered Architecture: Separating concerns between portable, driver, and provider layers | Builder Pattern: Using builders for flexible client configuration | Provider Loading: Dynamic loading of cloud provider implementations | Error Handling: Comprehensive error handling and recovery mechanisms | Extensibility: Support for custom providers and implementations | . ",
    "url": "/multicloudj/design/#design-decisions",
    
    "relUrl": "/design/#design-decisions"
  },"50": {
    "doc": "Design",
    "title": "Best Practices",
    "content": "When working with MultiCloudJ‚Äôs design: . | Keep it Simple: Prefer simple solutions over complex ones | Be Consistent: Follow established patterns and conventions | Think Ahead: Consider future extensibility and maintenance | Document Everything: Clear documentation is essential | Test Thoroughly: Ensure your changes work across all supported providers | . ",
    "url": "/multicloudj/design/#best-practices",
    
    "relUrl": "/design/#best-practices"
  },"51": {
    "doc": "Design",
    "title": "Related Resources",
    "content": ". | API Documentation | How-to Guides | Examples | Contribution Guidelines | . ",
    "url": "/multicloudj/design/#related-resources",
    
    "relUrl": "/design/#related-resources"
  },"52": {
    "doc": "Design",
    "title": "Design",
    "content": " ",
    "url": "/multicloudj/design/",
    
    "relUrl": "/design/"
  },"53": {
    "doc": "Getting Started",
    "title": "Quick Start",
    "content": "This tutorial provides a quick introduction to set up MultiCloudJ dependency and write a multi-cloud application with blobstore and docstore interface. 1. Add maven Dependencies . Each service have a $service-client such as blob-client artifact as well $service-$provider artifact such blob-aws. The $service-client is MUST HAVE at the build time and your application code uses this to write the code. The $service-$provider is required at the run time, and you can have dependencies for one or multiple providers at the same time. For example, you can have blob-aws, blob-gcp in your dependencies in your classpath at runtime and you can choose the provider during the client initialization. Add MultiCloudJ blob and docstore dependencies to your Maven project: . &lt;dependency&gt; &lt;groupId&gt;com.salesforce.multicloudj&lt;/groupId&gt; &lt;artifactId&gt;blob-client&lt;/artifactId&gt; &lt;version&gt;0.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.salesforce.multicloudj&lt;/groupId&gt; &lt;artifactId&gt;blob-aws&lt;/artifactId&gt; &lt;version&gt;0.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.salesforce.multicloudj&lt;/groupId&gt; &lt;artifactId&gt;blob-gcp&lt;/artifactId&gt; &lt;version&gt;0.2.2&lt;/version&gt; &lt;/dependency&gt; . Or for Gradle: . implementation 'com.salesforce.multicloudj:blob-client:0.2.2' implementation 'com.salesforce.multicloudj:blob-aws:0.2.2' implementation 'com.salesforce.multicloudj:blob-gcp:0.2.2' . 2. Set Up AWS Credentials . First, you need to configure AWS credentials on your machine. You have several options: . Option A: AWS CLI Configuration (Recommended) . Follow https://docs.aws.amazon.com/cli/v1/userguide/cli-chap-configure.html To get started, You can have AWS credentials on environment variables or the ~/.aws/credentials file. 3. Create an S3 Bucket . You can create a bucket using the AWS Console, AWS CLI, or programmatically: . # Using AWS CLI aws s3 mb s3://my-multicloudj-bucket --region us-west-2 . 4. Your First MultiCloudJ Application . Now let‚Äôs create a simple application that connects to your bucket and performs basic operations: . import com.salesforce.multicloudj.blob.client.BucketClient; import com.salesforce.multicloudj.blob.driver.UploadRequest; import com.salesforce.multicloudj.blob.driver.DownloadRequest; public class MultiCloudJQuickStart { public static void main(String[] args) { // Initialize a session to your S3 bucket BucketClient bucketClient = BucketClient.builder(\"aws\") .withRegion(\"us-west-2\") // Replace with your region .withBucket(\"my-multicloudj-bucket\") // Replace with your bucket name .build(); try { // Upload a blob System.out.println(\"Uploading blob...\"); UploadRequest uploadRequest = new UploadRequest(\"hello.txt\"); bucketClient.upload(uploadRequest, \"Hello, MultiCloudJ!\".getBytes()); System.out.println(\"Upload successful!\"); // Download the blob System.out.println(\"Downloading blob...\"); DownloadRequest downloadRequest = new DownloadRequest(\"hello.txt\"); byte[] content = bucketClient.download(downloadRequest); System.out.println(\"Downloaded content: \" + new String(content)); // List all blobs in the bucket System.out.println(\"Listing blobs in bucket...\"); bucketClient.listBlobs().forEach(blob -&gt; System.out.println(\"Found blob: \" + blob.getKey() + \" (size: \" + blob.getSize() + \" bytes)\") ); } catch (Exception e) { System.err.println(\"Error: \" + e.getMessage()); e.printStackTrace(); } } } . 5. Run Your Application (If you have IDE that‚Äôs better) . # Compile and run javac -cp \".:multicloudj-blob-0.2.2.jar\" MultiCloudJQuickStart.java java -cp \".:multicloudj-blob-0.2.2.jar\" MultiCloudJQuickStart . 6. What Just Happened? . | BucketClient Creation: We created a BucketClient instance that connects to your S3 bucket | Upload: We uploaded a simple text file with the content ‚ÄúHello, MultiCloudJ!‚Äù | Download: We downloaded the same file and displayed its content | List: We listed all objects in your bucket to see what‚Äôs there | . ",
    "url": "/multicloudj/getting-started/#quick-start",
    
    "relUrl": "/getting-started/#quick-start"
  },"54": {
    "doc": "Getting Started",
    "title": "Next Steps",
    "content": ". | Explore Guides: Check out our detailed guides for specific use cases | API Reference: Browse the complete Java API documentation | Examples: See working examples in our examples repository | Design Decisions: Understand the architecture and design principles | . ",
    "url": "/multicloudj/getting-started/#next-steps",
    
    "relUrl": "/getting-started/#next-steps"
  },"55": {
    "doc": "Getting Started",
    "title": "Getting Help",
    "content": ". | GitHub Issues: Report bugs and request features | Community: Join discussions | Contributing: Learn how to contribute | . MultiCloudJ is maintained by the Salesforce MultiCloudJ team and is open source under the Apache License 2.0. ",
    "url": "/multicloudj/getting-started/#getting-help",
    
    "relUrl": "/getting-started/#getting-help"
  },"56": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/multicloudj/getting-started/",
    
    "relUrl": "/getting-started/"
  },"57": {
    "doc": "Usage Guides",
    "title": "How-To Guides",
    "content": "Welcome to the MultiCloudJ How-To Guides. This section provides concise, task-focused guides designed to help you accomplish common goals using MultiCloudJ‚Äôs cloud-agnostic interfaces. Each guide is grouped by API and includes practical examples and usage patterns. ",
    "url": "/multicloudj/guides/#how-to-guides",
    
    "relUrl": "/guides/#how-to-guides"
  },"58": {
    "doc": "Usage Guides",
    "title": "üõ°Ô∏è STS",
    "content": "Learn how to get access credentials using roles/service accounts etc. | STS | . ",
    "url": "/multicloudj/guides/#%EF%B8%8F-sts",
    
    "relUrl": "/guides/#Ô∏è-sts"
  },"59": {
    "doc": "Usage Guides",
    "title": "‚òÅÔ∏è Blob",
    "content": "Learn how to manage object storage (uploading, downloading, listing blobs) in a cloud-neutral way. | Blob Store | . ",
    "url": "/multicloudj/guides/#%EF%B8%8F-blob",
    
    "relUrl": "/guides/#Ô∏è-blob"
  },"60": {
    "doc": "Usage Guides",
    "title": "üìÑ Docstore",
    "content": "Work with document-oriented databases using a consistent interface. | Docstore | . ",
    "url": "/multicloudj/guides/#-docstore",
    
    "relUrl": "/guides/#-docstore"
  },"61": {
    "doc": "Usage Guides",
    "title": "üì¨ Pub/Sub",
    "content": "Use publish/subscribe systems to send and receive messages. | Pubsub | . ",
    "url": "/multicloudj/guides/#-pubsub",
    
    "relUrl": "/guides/#-pubsub"
  },"62": {
    "doc": "Usage Guides",
    "title": "üß™ Testing",
    "content": "Learn how to write and run conformance tests for multi-cloud applications. | Conformance Tests | . Explore these guides to master the MultiCloudJ SDK and build robust multi-cloud Java applications with ease. ",
    "url": "/multicloudj/guides/#-testing",
    
    "relUrl": "/guides/#-testing"
  },"63": {
    "doc": "Usage Guides",
    "title": "Usage Guides",
    "content": " ",
    "url": "/multicloudj/guides/",
    
    "relUrl": "/guides/"
  },"64": {
    "doc": "Layers",
    "title": "Layers",
    "content": " ",
    "url": "/multicloudj/design/layers.html",
    
    "relUrl": "/design/layers.html"
  },"65": {
    "doc": "Layers",
    "title": "Introduction",
    "content": "The Substrate SDK uses a layered architecture to provide a clean separation between the public API, internal abstractions, and provider-specific implementations. This architecture enables: . | A consistent, substrate-agnostic experience for end users | Easy addition of new cloud providers | Clear separation of concerns | Maintainable and testable code | . ",
    "url": "/multicloudj/design/layers.html#introduction",
    
    "relUrl": "/design/layers.html#introduction"
  },"66": {
    "doc": "Layers",
    "title": "Components",
    "content": ". The architecture consists of three main layers: . | Portable Layer (Top) - The public-facing API that users interact with | Driver Layer (Middle) - The abstraction layer that defines common interfaces | Provider Layer (Bottom) - The implementation layer for specific cloud providers | . ",
    "url": "/multicloudj/design/layers.html#components",
    
    "relUrl": "/design/layers.html#components"
  },"67": {
    "doc": "Layers",
    "title": "Portable Layer",
    "content": "The portable layer is the most important and front-facing layer for end users. End users should mostly interact with the portable Layer to make cloud service calls. The portable Layer should expose all necessary functions/APIs for the end user. For example, for a blobstore service, it can expose methods like upload, download, delete, etc., through the portable Layer. Characteristics of an ideal portable Layer: . | The portable Layer should be substrate-agnostic, containing no substrate-specific logic. It should offer a substrate-agnostic experience for the end user. | The portable Layer should accept the substrate(provider) value from the end user and initiate the appropriate session on that substrate. (We might consider that empty provider will pick whatever provider it finds first in the classpath, if required). | The portable Layer should allow users to provide substrate-agnostic inputs such as region name, credentials through a credentials provider defined in Substrate SDK, bucket name (for blob services), etc. | The portable Layer should only expose functions that are supported across all substrates. It should not support or expose features that work on one substrate but not on others. | The portable Layer should strive to provide the best experience for the end user, requiring as little information as possible. | . Example usage of the portable Layer for blob storage and uploading the blob: . // hardcodes for illustration purposes values should be outside of the service code String substrate = \"aws\" String region = \"us-east-1\" // Setting up session credentials - // these are optional and ideally in prod, this is not required // since the k8s pods are set with default credentials and Substrate SDK // uses the default credentials in that case. StsCredentials credentials = new StsCredentials( \"accessKeyId\", \"accessKeySecret\", \"sessionToken\"); CredentialsOverrider credsOverrider = new CredentialsOverrider .Builder(CredentialsType.SESSION).withSessionCredentials(credentials).build(); // Initiate the substrate agnostic BucketClient BucketClient client = BucketClient.builder(substrate) .withBucket(\"chameleon-java\") .withRegion(region) .withCredentialsOverrider(credsOverrider).build(); // Prepare the substrate agnostic UploadRequest UploadRequest uploadRequest = new UploadRequest.Builder() .withKey(\"bucket-path/chameleon.jpg\") // Upload the content UploadResponse response = client.upload(uploadRequest, \"dummy-content\"); . The above example demonstrates that the end user wants to open the client for the blob storage in the AWS substrate to the bucket ‚Äúchameleon-java‚Äù in the region ‚Äúus-east-1‚Äù. The client is used to upload/write the blob in the bucket. In this example, the portable fulfills all the requirements as discussed above: . | There is no substrate specific logic exposed on the portable Layer. From the code block, there is no substrate specific exposure and this logic works in the same manner for other substrates by just providing a different substrate value. | portable Layer forces the client the provide a substrate value, it doesn‚Äôt assume or interpret the substrate based on the runtime. | It provides a way to supply inputs to open the session in a substrate agnostic manner. | It asks the minimum amount of information from the end user without knowing the internals of the SDK. | . ",
    "url": "/multicloudj/design/layers.html#portable-layer",
    
    "relUrl": "/design/layers.html#portable-layer"
  },"68": {
    "doc": "Layers",
    "title": "Driver Layer",
    "content": "The driver layer is a layer behind the portable Layer which defines the abstract functions and implementations for each substrate/provider. The driver layer can also include wrapper logic on top of abstract functions to further simplify portable Layer. Structure . The basic structure of abstract Blob Store looks like this which defines some variables required for the provider implementation such as region and the provider id: . public abstract class AbstracBlobtore { protected final String providerId; protected final String region; protected final String bucket; // Abstract methods for substrate-specific implementations protected abstract UploadResponse doUpload(UploadRequest uploadRequest); protected abstract DownloadResponse doDownload(DownloadRequest downloadRequest); protected abstract void doDelete(String key); } . Why do need a separate driver layer? . While it‚Äôs possible to achieve the abstraction of service capabilities without this driver layer and instead make the portable layer an abstract class, there are numerous benefits to keeping the portable layer separate. These benefits include: . Separation of concerns: . Abstract classes deal with internal code of SDK and abstract methods for providers to implement where as portable Layer or client is all about external facing code. We can keep the portable Layer light weight and to the point. Driver abstraction consist of: . | Common methods for logic which applies to all providers | Abstract methods to be implemented by providers | . Prevention of leaky abstractions: . Having a separate portable Layer prevents the leaky abstractions because the client doesn‚Äôt have to deal with or access the driver layer which might expose some internals. Maintainability: . Changing the internal implementations are comparatively safe without breaking portable Layer contracts. Testing: . End users have simple portable layer for mocks and testing. Example: . For instance, the upload method in BucketClient have multiple methods in the backend, such as validateContent to validate if the content is in the right format which is common for all providers. This validateContent method should be internal and not exposed to end users, therefore it can be part of driver layer and keep the BucketClient purely public. Secondly, if we have a prepContent abstraction function in driver which should be implemented by all the provider implementations to prepareContent for specific substrate. Now, let‚Äôs say each substrate appends the content with some prefix bytes which are substrate specific. So the upload method is executed as follow behind the scenes: . public UploadResponse upload(UploadRequest uploadRequest) { validation(); &lt;- this is common validation for all substrates prepContent(); &lt;- this is provider specific prep content doUpload(); this is provider specific upload of the content } . Basically we might have several methods which the end user doesn‚Äôt care about and should be completely abstracted from the users. These functions should be placed in driver layer, keeping the portable layer purely public and sanitized. ",
    "url": "/multicloudj/design/layers.html#driver-layer",
    
    "relUrl": "/design/layers.html#driver-layer"
  },"69": {
    "doc": "Layers",
    "title": "Provider Layer",
    "content": "Provider layer implements the driver layer for each substrate. Provider layer is for each provider or substrate which powers the API calls from the end users to make substrate specific calls. In the below code example: AWSBlobStore is the provider for blob/blobstore for AWS substrate and implements all the abstract functions in the AWS substrate. public class AWSBlobStore extends AbstractBlobStore { S3Client s3Client; public AWSBlobStore(Builder builder) { s3Client = ... // code logic to build the s3Client by information from builder } @Override protected void doUploadFile(String key, String filePath) { Map&lt;String, String&gt; metadata = new HashMap&lt;&gt;(); PutObjectRequest putOb = PutObjectRequest.builder() .bucket(this.bucketName) .key(key) .metadata(metadata) .build(); s3Client.putObject(putOb, RequestBody.fromFile(new File(filePath))); log.info(\"Successfully placed object\" + \" into bucket \" + bucketName); } @Override public Builder builder() { return new Builder(); } public static class Builder extends AbstractBlobStore.Builder&lt;AwsBlobStore&gt; { public Builder() { providerId(\"aws\"); } @Override public AwsBlobStore build() { return new AwsBlobStore(this); } ... } } . ",
    "url": "/multicloudj/design/layers.html#provider-layer",
    
    "relUrl": "/design/layers.html#provider-layer"
  },"70": {
    "doc": "Layers",
    "title": "Best Practices",
    "content": ". | Keep the Portable Layer Clean . | Only expose substrate-agnostic APIs | Validate inputs before passing to driver layer | Handle common error cases | . | Driver Layer Design . | Define clear interfaces | Include common validation logic | Provide default implementations where possible | Document expected behavior | . | Provider Implementation . | Follow the driver layer contract strictly | Handle provider-specific edge cases | Implement proper error handling | Add provider-specific logging | . | . ",
    "url": "/multicloudj/design/layers.html#best-practices",
    
    "relUrl": "/design/layers.html#best-practices"
  },"71": {
    "doc": "Layers",
    "title": "Common Pitfalls",
    "content": ". | Leaky Abstractions . | Avoid exposing provider-specific types in the portable layer | Don‚Äôt let provider-specific exceptions bubble up | Keep provider-specific configuration internal | . | Inconsistent Behavior . | Ensure all providers implement the same behavior | Handle edge cases consistently | Document any provider-specific limitations | . | Performance Issues . | Avoid unnecessary abstraction layers | Cache provider clients when possible | Use efficient data structures | . | . ",
    "url": "/multicloudj/design/layers.html#common-pitfalls",
    
    "relUrl": "/design/layers.html#common-pitfalls"
  },"72": {
    "doc": "How to STS",
    "title": "STS (Security Token Service)",
    "content": "The StsClient class in the multicloudj library provides a portable interface for interacting with cloud provider security token services such as AWS STS, GCP IAM Credentials, or any other compatible implementation. It allows you to obtain temporary credentials, access tokens, and caller identity information in a cloud-neutral way. ",
    "url": "/multicloudj/guides/sts-guide.html#sts-security-token-service",
    
    "relUrl": "/guides/sts-guide.html#sts-security-token-service"
  },"73": {
    "doc": "How to STS",
    "title": "Overview",
    "content": "The StsClient is built on top of provider-specific implementations of AbstractSts. Each provider registers its implementation and is selected dynamically at runtime. ",
    "url": "/multicloudj/guides/sts-guide.html#overview",
    
    "relUrl": "/guides/sts-guide.html#overview"
  },"74": {
    "doc": "How to STS",
    "title": "Feature Support Across Providers",
    "content": "Core API Features . | Feature Name | GCP | AWS | ALI | Comments | . | Assume Role | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Core feature for temporary credentials for role/service account | . | Get Caller Identity | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Returns identity information of the current caller | . | Get Access Token | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Get credentials using default env configs | . Configuration Options . | Configuration | GCP | AWS | ALI | Comments | . | Region Support | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | All providers support region-specific operations | . | Endpoint Override | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported | Custom endpoint configuration | . Provider-Specific Notes . GCP (Google Cloud Platform) . | Uses Google‚Äôs OAuth 2.0 access tokens for credentials and ID tokens for Caller Identity | . ",
    "url": "/multicloudj/guides/sts-guide.html#feature-support-across-providers",
    
    "relUrl": "/guides/sts-guide.html#feature-support-across-providers"
  },"75": {
    "doc": "How to STS",
    "title": "Creating a Client",
    "content": "StsClient stsClient = StsClient.builder(\"aws\") .withRegion(\"us-west-2\") .build(); . Optionally, you can set a custom endpoint: . URI endpoint = URI.create(\"https://sts.custom-endpoint.com\"); StsClient stsClient = StsClient.builder(\"aws\") .withRegion(\"us-west-2\") .withEndpoint(endpoint) .build(); . ",
    "url": "/multicloudj/guides/sts-guide.html#creating-a-client",
    
    "relUrl": "/guides/sts-guide.html#creating-a-client"
  },"76": {
    "doc": "How to STS",
    "title": "Getting Caller Identity",
    "content": "Retrieve the caller identity associated with the current credentials: . CallerIdentity identity = stsClient.getCallerIdentity(); System.out.println(\"Caller: \" + identity.getArn()); . ",
    "url": "/multicloudj/guides/sts-guide.html#getting-caller-identity",
    
    "relUrl": "/guides/sts-guide.html#getting-caller-identity"
  },"77": {
    "doc": "How to STS",
    "title": "Getting an Access Token",
    "content": "Use this when you need an OAuth2-style token (provider support may vary): . GetAccessTokenRequest request = new GetAccessTokenRequest(); StsCredentials token = stsClient.getAccessToken(request); System.out.println(\"Access Token: \" + token.getAccessToken()); . ",
    "url": "/multicloudj/guides/sts-guide.html#getting-an-access-token",
    
    "relUrl": "/guides/sts-guide.html#getting-an-access-token"
  },"78": {
    "doc": "How to STS",
    "title": "Assuming a Role",
    "content": "To assume a different identity (e.g., for cross-account access): . AssumedRoleRequest request = new AssumedRoleRequest(); request.setRoleArn(\"arn:aws:iam::123456789012:role/example-role\"); request.setSessionName(\"example-session\"); StsCredentials credentials = stsClient.getAssumeRoleCredentials(request); System.out.println(\"Temporary Credentials: \" + credentials.getAccessKeyId()); . ",
    "url": "/multicloudj/guides/sts-guide.html#assuming-a-role",
    
    "relUrl": "/guides/sts-guide.html#assuming-a-role"
  },"79": {
    "doc": "How to STS",
    "title": "Error Handling",
    "content": "All errors are translated to SubstrateSdkException subclasses by the underlying driver. The client will automatically map exceptions to meaningful runtime errors based on the provider: . try { CallerIdentity identity = stsClient.getCallerIdentity(); } catch (SubstrateSdkException e) { // Handle known errors: AccessDenied, Timeout, etc. e.printStackTrace(); } . ",
    "url": "/multicloudj/guides/sts-guide.html#error-handling",
    
    "relUrl": "/guides/sts-guide.html#error-handling"
  },"80": {
    "doc": "How to STS",
    "title": "How to STS",
    "content": " ",
    "url": "/multicloudj/guides/sts-guide.html",
    
    "relUrl": "/guides/sts-guide.html"
  }
}
